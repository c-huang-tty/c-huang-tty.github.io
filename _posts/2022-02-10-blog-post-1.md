---
title: 'Data Aggregation [01]: GroupBy Method'
date: 2022-02-10
permalink: /posts/2022/02/10/data-aggregation-groupby/
tags:
  - Data Aggregation
  - GroupBy
---

Group operations involves three stages:
1. **split**: object is split into groups based on one or more keys
2. **apply**: a function is applied to each group, producing a new value
3. **combine**: results of are combined into a result object

---
## Basics
In pandas, we use `DataFrame.group()` to realize the three steps.
```python
DataFrame.groupby(by=None, 
                  axis=0, 
                  level=None, 
                  as_index=True, 
                  sort=True, 
                  group_keys=True, 
                  squeeze=NoDefault.no_default, 
                  observed=False, dropna=True)
```
Parameters:
- `by`: mapping, function, label, or list of labels
  - Used to determine the groups for the groupby. 
    - If `by` is a function, it’s called on each value of the object's index. 
    - If a dict or Series is passed, the Series or dict VALUES will be used to determine the groups. 
    - If a list or ndarray of length equal to the selected axis is passed, the values are used to determine the groups. 
- `axis`: {0 or ‘index’, 1 or ‘columns’}, default 0
- `level`: int, level name, or sequence of such, default None
  - If the axis is a MultiIndex (hierarchical), group by a particular level or levels.
- `as_index`: bool, default True
  - For aggregated output, return object with group labels as the index. Only relevant for DataFrame input. as_index=False is effectively "SQL-style" grouped output.
- `sort`: bool, default True
  - Sort group keys.
- `group_keys`: bool, default True
  - When calling apply, add group keys to index to identify pieces.
- `observed`: bool, default False
  - This only applies if any of the groupers are Categoricals.
    - If True: only show observed values for categorical groupers. 
    - If False: show all values for categorical groupers.
- `dropna`: bool, default True
  - If True, and if group keys contain NA values, NA values together with row/column will be dropped. 
  - If False, NA values will also be treated as the key in groups.

### Simple Group
```python
df = pd.DataFrame(
    {
        "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
        "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
        "C": np.random.randn(8),
        "D": np.random.randn(8),
    }
)

grouped = df.groupby("A")

# check the size of the group, there 3 for 'bar' and 5 for 'foo'
grouped.size()
Out[26]: 
A
bar    3
foo    5
dtype: int64

# get the mean of 'C' and 'D'
grouped.mean()
Out[27]: 
            C         D
A                      
bar  0.174952  0.025694
foo  0.134058  0.564041

# We can also split the DataFrame by colum
def get_letter_type(letter):
    if letter.lower() in 'aeiou':
        return 'vowel'
    else:
        return 'consonant'

# assign 'A' to the first group and 'B', 'C', 'D' to another group
grouped = df.groupby(get_letter_type, axis=1)
grouped.size()
Out[138]: 
consonant    3
vowel        1
dtype: int64

# print
# every element in the GroupBy object is a tuple, 
# where the first element is the group name, and the second
# is the group values
for i in grouped:
    print(i[0])
    print(i[1])

# This is the same as
for name, group in grouped:
    print(name)
    print(group)

consonant
       B         C         D
0    one  0.697843  0.732219
1    one -0.945606 -0.319682
2    two  0.058214 -0.622784
3  three  0.228985  0.951989
4    two -0.486862  0.886640
5    two -0.168847 -1.489620
6    one  1.976851 -0.322967
7  three -1.314112 -1.147206
vowel
     A
0  foo
1  bar
2  foo
3  bar
4  foo
5  bar
6  foo
7  foo
```

---
