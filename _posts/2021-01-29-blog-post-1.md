---
title: 'Statistics [29]: Factor Analysis'
date: 2021-01-29
permalink: /posts/2021/01/29/factor-principle-component-analysis/
tags:
  - Statistics
---

In practice, data may contain many variables, however, not all of them have significant influence on the results we want to analysis or predict. Factor analysis and principle component analysis are two basic methods that aim to reduce the dimension of the data to make it easier to understand and analyze. This psot summarizes the basics of factor analysis.

---
---
# Factor Analysis

---
## Notations
Observabale variable (with <img src="https://render.githubusercontent.com/render/math?math=p"> traits): 

<img src="https://render.githubusercontent.com/render/math?math=X = (X_1, X_2, ..., X_p)^T">

Common factors (with <img src="https://render.githubusercontent.com/render/math?math=m"> factors): 

<img src="https://render.githubusercontent.com/render/math?math=f = (f_1, f_2, ..., f_m),\ \ m\ll p">

The factor model can be thought of as a series of multiple regressions:
  
<img src="https://render.githubusercontent.com/render/math?math=X_1 = \mu_1 %2B l_{11}f_1 %2B l_{12}f_2 %2B \cdots %2B l_{1m}f_m %2B \epsilon_1">

<img src="https://render.githubusercontent.com/render/math?math=X_2 = \mu_2 %2B l_{21}f_1 %2B l_{22}f_2 %2B \cdots %2B l_{2m}f_m %2B \epsilon_2">

<img src="https://render.githubusercontent.com/render/math?math=\vdots">

<img src="https://render.githubusercontent.com/render/math?math=X_p = \mu_1 %2B l_{p1}f_1 %2B l_{p2}f_2 %2B \cdots %2B l_{pm}f_m %2B \epsilon_p">

where <img src="https://render.githubusercontent.com/render/math?math=l_{ij}"> are called factor loadings.

In matrix form:

<img src="https://render.githubusercontent.com/render/math?math=X = \mu %2B Lf %2B \epsilon">

where 

<img src="https://render.githubusercontent.com/render/math?math=\Lambda = \diag(\lambda_1,\lambda_2,...,\lambda_p), \ \ V = [v_1,v_2,...,v_p]">

---
## Assumptions
### Mean
<img src="https://render.githubusercontent.com/render/math?math=E(\epsilon_i) = 0, i=1,2,...,p">

<img src="https://render.githubusercontent.com/render/math?math=E(f_j) = 0, j=1,2,...,m">

Hence,

<img src="https://render.githubusercontent.com/render/math?math=E(X_i) = \mu_i, i=1,2,...,p">

### Variance
<img src="https://render.githubusercontent.com/render/math?math=var(\epsilon_i) = \psi_i, i=1,2,...,p">, where <img src="https://render.githubusercontent.com/render/math?math=\psi_i"> is the specific variance.

<img src="https://render.githubusercontent.com/render/math?math=var(f_j) = 1, j=1,2,...,m">

### Correlation
<img src="https://render.githubusercontent.com/render/math?math=cov(f_i,f_j) = 0,\ \ \text{for}\ \ i\neq j">

<img src="https://render.githubusercontent.com/render/math?math=cov(\epsilon_i,\epsilon_j) = 0,\ \ \text{for}\ \ i\neq j">

<img src="https://render.githubusercontent.com/render/math?math=cov(\epsilon_i,f_j) = 0,\ \ \text{for}\ \ i=1,2,...,p%3B j=1,2,...,m">

### Model Properties
<img src="https://render.githubusercontent.com/render/math?math={\displaystyle \sigma_i^2 = var(X_i) = E[(X_i-E(X_i))^2] = E[(l_{i1}f_1 %2B l_{i2}f_2 %2B \cdots %2B l_{im}f_m %2B \epsilon_i)^2] = \sum_{j=1}^ml_{ij}^2 %2B \psi_i}">

where <img src="https://render.githubusercontent.com/render/math?math={\displaystyle \sum_{j=1}^ml_{ij}^2}"> is called the __communality__ of the variable <img src="https://render.githubusercontent.com/render/math?math=i">.

<img src="https://render.githubusercontent.com/render/math?math={\displaystyle \sigma_{ij} = cov(X_i,X_j) = E[(X_i-E(X_i))(X_j-E(X_j))] = E[(l_{i1}f_1 %2B l_{i2}f_2 %2B \cdots %2B l_{im}f_m %2B \epsilon_i)(l_{j1}f_1 %2B l_{j2}f_2 %2B \cdots %2B l_{jm}f_m %2B \epsilon_j)] = \sum_{k=1}^ml_{ik}l_{jk}}">

<img src="https://render.githubusercontent.com/render/math?math={\displaystyle cov(X_i,f_j) = l_{ij}}">

In matrix form:

<img src="https://render.githubusercontent.com/render/math?math={\displaystyle \Sigma = LL^T %2B \Psi}">

where <img src="https://render.githubusercontent.com/render/math?math={\displaystyle \Psi = \diag(\psi_1,\psi_2,...,\psi_p)}">

As <img src="https://render.githubusercontent.com/render/math?math={\displaystyle \Sigma}"> is a symmetric matrix, there are <img src="https://render.githubusercontent.com/render/math?math={\displaystyle \dfrac{p(p%2B 1)}{2}}"> parameters in total, which are to be approximated by <img src="https://render.githubusercontent.com/render/math?math={\displaystyle mp%2B p}"> parameters. 

---
## Principle Component Method
Let <img src="https://render.githubusercontent.com/render/math?math=X_i,i=1,2,...,n"> denote the samples, with

<img src="https://render.githubusercontent.com/render/math?math=X_i = (X_{i1},X_{i2},...,X_{ip})^T">

<img src="https://render.githubusercontent.com/render/math?math=S"> denotes the sample variance matrix,

<img src="https://render.githubusercontent.com/render/math?math=S = \dfrac{1}{n-1}{\displaystyle \sum_{i=1}^n(X_i-\bar{X})(X_i-\bar{X})^T}">

We have <img src="https://render.githubusercontent.com/render/math?math=p"> eigenvalues and <img src="https://render.githubusercontent.com/render/math?math=p"> eigenvectors for this matrix.

Eigenvalues: <img src="https://render.githubusercontent.com/render/math?math=\lambda_1,\lambda_2,...\lambda_p">

Eigenvectors: <img src="https://render.githubusercontent.com/render/math?math=v_1,v_2,...,v_p">

Then we can express the covariance matrix with eigenvalues and eigenfactors as

<img src="https://render.githubusercontent.com/render/math?math=S = V\Lambda V^T = {\displaystyle \sum_{i=1}^p\lambda_iv_iv_i^T}">

The idea behind the principal component method is to approximate this expression. Instead of summing from <img src="https://render.githubusercontent.com/render/math?math=1"> to <img src="https://render.githubusercontent.com/render/math?math=p">, we sum from 1 to <img src="https://render.githubusercontent.com/render/math?math=m">, ignoring the <img src="https://render.githubusercontent.com/render/math?math=p-m"> terms. 

We can rewrite the covariance matrix as 

<img src="https://render.githubusercontent.com/render/math?math={\displaystyle S \approx \sum_{i=1}^m\lambda_iv_iv_i^T = \sum_{i=1}^m\hat{l}_i\hat{l}_i^T, \hat{l}_i = (\hat{l}_{1i},\hat{l}_{2i},...,\hat{l}_{pi})^T}">

This yields the estimator for the factor loadings:

<img src="https://render.githubusercontent.com/render/math?math={\displaystyle \hat{l}_{ij} = v_{ji}\sqrt{\lambda_j}\ \ \text{or}\ \ \hat{l}_{ji} = v_{ij}\sqrt{\lambda_i}}">

To estimate the specific variances <img src="https://render.githubusercontent.com/render/math?math=\Psi">, we only need to estimate the diagonal elements,

<img src="https://render.githubusercontent.com/render/math?math=\hat{\psi}_i = s_i^2 - \sum_{j=1}^m l_{ij}^2 = s_i^2 - {\displaystyle \sum_{j=1}^m\lambda_jv_{ji}^2}">

---
## Maximum Likelihood Estimation Method
Using the Maximum Likelihood Estimation Method, we must assume that the data are independently sampled from a multivariate normal distribution with mean vector <img src="https://render.githubusercontent.com/render/math?math=\mu"> and covariance matrix of the form:

<img src="https://render.githubusercontent.com/render/math?math=\Sigma = LL^T %2B \Psi">

The maximum likelihood estimator for the mean vector <img src="https://render.githubusercontent.com/render/math?math=\mu">, the factor loading matrix <img src="https://render.githubusercontent.com/render/math?math=L"> and the specific variance <img src="https://render.githubusercontent.com/render/math?math=\Psi"> are obtained by finding <img src="https://render.githubusercontent.com/render/math?math=\hat{\mu}">, <img src="https://render.githubusercontent.com/render/math?math=\hat{L}"> and <img src="https://render.githubusercontent.com/render/math?math=\hat{\Psi}"> that maximize the maximize the log likelihood given by:

<img src="https://render.githubusercontent.com/render/math?math=l(\mu,L,\Psi) = -\dfrac{np}{2}\log 2\pi -\dfrac{n}{2}\log|LL^T%2B \Psi| - \dfrac{1}{2}{\displaystyle \sum_{i=1}^n(X_i-\mu)^T(LL^T%2B \Psi)^{-1}(X_i-\mu)} ">

which can be obtained using the multivariate normal distribution given in [this](https://c-huang-tty.github.io/posts/2021/01/07/multivariate-normal-distributions/) post.

---
## Goodness of Fit
To assess goodness-of-fit, we use the Bartlett-Corrected Likelihood Ratio Test Statistic ([link](https://online.stat.psu.edu/stat505/lesson/12/12.9)):

<img src="https://render.githubusercontent.com/render/math?math=X^2 = \left(n-1-\dfrac{2p%2B 4m -5}{6}\right)\log\dfrac{\left|\hat{L}\hat{L}^T%2B \Psi\right|}{|\hat{\Sigma}|}">

In the numerator we have the determinant of the fitted factor model for the variance-covariance matrix, and below, we have a sample estimate of the variance-covariance matrix assuming no structure where:

<img src="https://render.githubusercontent.com/render/math?math=\hat{\Sigma} = \dfrac{n-1}{n}S">

and <img src="https://render.githubusercontent.com/render/math?math=S"> is the sample covariance matrix.

If the factor model fits well then these two determinants should be about the same and you will get a small value for <img src="https://render.githubusercontent.com/render/math?math=X^2">. Otherwise, <img src="https://render.githubusercontent.com/render/math?math=X^2"> would be large.

Under the null hypothesis that the factor model adequately describes the relationships among the variables, there is

<img src="https://render.githubusercontent.com/render/math?math=X^2\sim \chi^2((p^2-p-2pm)\text{/}2)">

where the degrees of freedom are the difference of unique parameters in the two models.

---
## Factor Rotations
The problem with the analysis above is that some of the variables are highlighted by more than one factors, and some even indicate contradictory results. This does not provide a very clean, simple interpretation of the data. __Ideally, each variable would appear as a significant contributer in one column (factor)__. This is the purpose of factor rotations.

Factor rotation is motivated by the fact that factor models are not unique. To see this, let <img src="https://render.githubusercontent.com/render/math?math=T"> be any <img src="https://render.githubusercontent.com/render/math?math=m\times m"> orthogonal matrix. We can write the factor model as:

<img src="https://render.githubusercontent.com/render/math?math=X=\mu %2B Lf %2B \epsilon =\mu %2B LTT^Tf %2B \epsilon = \mu %2B L^*f^* %2B \epsilon\ \ (L^*=LT, f^*=T^Tf)">

We can verify that the assumptions still hold under the trasform. 

### Varimax Rotation
Varimax rotation finds the rotation that maximizes the sum of the variances of the squared loadings, namely, find <img src="https://render.githubusercontent.com/render/math?math=T">, such that  

<img src="https://render.githubusercontent.com/render/math?math=V = {\displaystyle \dfrac{1}{p} \sum_{j=1}^m\left\{\sum_{i=1}^p(\tilde{l}_{ij}^*)^4 - \dfrac{1}{p}\left(\sum_{i=1}^p(\tilde{l}_{ij}^*)^2\right)^2\right\}}">

is maximized, where 

<img src="https://render.githubusercontent.com/render/math?math=\tilde{l}_{ij}^* = \dfrac{\hat{l}_{ij}^*}{\hat{h}_i}">

and 

<img src="https://render.githubusercontent.com/render/math?math=\hat{h}_i^2 = {\displaystyle \sum_{j=1}^m\hat{l}_{ij}^2}">

---
## Estimation of Factor Scores
Given the factor model:

<img src="https://render.githubusercontent.com/render/math?math=Y_i = \mu %2B Lf_i %2B \epsilon_i, i=1,2,...,n">

estimate the vectors of factor scores

<img src="https://render.githubusercontent.com/render/math?math=f_1,f_2,...,f_n">

for each observation.

### Ordinary Least Squares (OLS)
The factor scores is found by minimizing the sum of the residual squares:

<img src="https://render.githubusercontent.com/render/math?math=\epsilon_i^T\epsilon_i = (Y_i-\mu-Lf_i)^T(Y_i-\mu-Lf_i)">

Thus, 

<img src="https://render.githubusercontent.com/render/math?math=\hat{f}_i = (L^TL)^{-1}L^T(Y_i-\mu)">

### Weightead Least Squares (WLS)
The difference between WLS and OLS is that the squared residuals are divided by the specific variances <img src="https://render.githubusercontent.com/render/math?math=\psi">. This is going to give more weight, in this estimation, to variables that have low specific variances.  

The factor scores is found by minimizing the sum of the residual squares:

<img src="https://render.githubusercontent.com/render/math?math=\epsilon_i^T\Psi^{-1}\epsilon_i = (Y_i-\mu-Lf_i)^T\Psi^{-1}(Y_i-\mu-Lf_i)">

Thus, 

<img src="https://render.githubusercontent.com/render/math?math=\hat{f}_i = (L^TL)^{-1}L^T\Psi^{-1}(Y_i-\mu)">

---
## Example 
### Data
[Here](https://towardsdatascience.com/factor-analysis-a-complete-tutorial-1b7621890e42) is an example using package `factor_analyzer`. Let repeat the example using `statsmodel`. 

The dataset contains an airline passenger satisfaction survey, which has 25976 observations and 25 columns. 
```
       Unnamed: 0     id  ... Arrival Delay in Minutes             satisfaction
0               0  19556  ...                     44.0                satisfied
1               1  90035  ...                      0.0                satisfied
2               2  12360  ...                      0.0  neutral or dissatisfied
3               3  77959  ...                      6.0                satisfied
4               4  36875  ...                     20.0                satisfied
          ...    ...  ...                      ...                      ...
25971       25971  78463  ...                      0.0  neutral or dissatisfied
25972       25972  71167  ...                      0.0                satisfied
25973       25973  37675  ...                      0.0  neutral or dissatisfied
25974       25974  90086  ...                      0.0                satisfied
25975       25975  34799  ...                      0.0  neutral or dissatisfied

[25976 rows x 25 columns]
```
Here is a list of the 25 columns, where the columns 8 to 21 represent customers response on a scale of 1 to 5 to a survey evaluating different aspects of the flights. 
```
['Unnamed: 0',
 'id',
 'Gender',
 'Customer Type',
 'Age',
 'Type of Travel',
 'Class',
 'Flight Distance',
 'Inflight wifi service',
 'Departure/Arrival time convenient',
 'Ease of Online booking',
 'Gate location',
 'Food and drink',
 'Online boarding',
 'Seat comfort',
 'Inflight entertainment',
 'On-board service',
 'Leg room service',
 'Baggage handling',
 'Checkin service',
 'Inflight service',
 'Cleanliness',
 'Departure Delay in Minutes',
 'Arrival Delay in Minutes',
 'satisfaction']
 ```
The first step of any factor analysis is to look at a correlation plot of all the variables to see if any variables are useless or too correlated with others.
```python
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

data = pd.read_csv('airline.csv',sep=',')

c = data.corr()
ax = sns.heatmap(c,square=True)
ax.figure.subplots_adjust(bottom = 0.25)
```
<img src="/images/statistics/FA3.png" alt="drawing" width="800"/>

As "Departure Delay in Minutes" and the "Arrival Delay in Minutes" are highly correlated, remove one of the columns from the dataset.

```python
data.drop(['Arrival Delay in Minutes'], axis=1, inplace=True)
```

---
## Table of Contents
- [Probability vs Statistics](https://c-huang-tty.github.io/posts/2021/01/01/probability-and-statistics/)
- [Shakespear's New Poem](https://c-huang-tty.github.io/posts/2021/01/02/application-of-statistics/)
- [Some Common Discrete Distributions](https://c-huang-tty.github.io/posts/2021/01/03/some-common-discrete-distributions/)
- [Some Common Continuous Distributions](https://c-huang-tty.github.io/posts/2021/01/04/some-common-continuous-distributions/)
- [Statistical Quantities](https://c-huang-tty.github.io/posts/2021/01/05/statistical-quantities/)
- [Order Statistics](https://c-huang-tty.github.io/posts/2021/01/06/order-statistics/)
- [Multivariate Normal Distributions](https://c-huang-tty.github.io/posts/2021/01/07/multivariate-normal-distributions/)
- [Conditional Distributions and Expectation](https://c-huang-tty.github.io/posts/2021/01/08/conditonal-distributions-and-expectation/)
- [Problem Set [01] - Probabilities](https://c-huang-tty.github.io/posts/2021/01/21/problem-set-probabilities/)
- [Parameter Point Estimation](https://c-huang-tty.github.io/posts/2021/01/09/parameter-point-estimation/)
- [Evaluation of Point Estimation](https://c-huang-tty.github.io/posts/2021/01/10/evaluation-point-estimation/)
- [Parameter Interval Estimation](https://c-huang-tty.github.io/posts/2021/01/11/parameter-interval-estimation/)
- [Problem Set [02] - Parameter Estimation](https://c-huang-tty.github.io/posts/2021/01/22/problem-set-parameter-estimation/)
- [Parameter Hypothesis Test](https://c-huang-tty.github.io/posts/2021/01/12/parameter-hypothesis-test/)
- [t Test](https://c-huang-tty.github.io/posts/2021/01/13/t-test/)
- [Chi-Squared Test](https://c-huang-tty.github.io/posts/2021/01/14/chi-squared-test/)
- [Analysis of Variance](https://c-huang-tty.github.io/posts/2021/01/15/analysis-of-variance/)
- [Summary of Statistical Tests](https://c-huang-tty.github.io/posts/2021/01/16/summary-of-statistical-tests/)
- [Python [01] - Data Representation](https://c-huang-tty.github.io/posts/2021/01/17/statistics-python-data-representation/)
- [Python [02] - t Test & F Test](https://c-huang-tty.github.io/posts/2021/01/18/statistics-python-t-F-test/)
- [Python [03] - Chi-Squared Test](https://c-huang-tty.github.io/posts/2021/01/19/statistics-chi-squared-test/)
- [Experimental Design](https://c-huang-tty.github.io/posts/2021/01/20/experimental-design/)
- [Monte Carlo](https://c-huang-tty.github.io/posts/2021/01/23/monte-carlo/)
- [Variance Reducing Techniques](https://c-huang-tty.github.io/posts/2021/01/24/variance-reducing-techniques/)
- [From Uniform to General Distributions](https://c-huang-tty.github.io/posts/2021/01/25/from-uniform-to-general-distributions/)
- [Problem Set [03] - Monte Carlo](https://c-huang-tty.github.io/posts/2021/01/26/problem-set-monte-carlo/)
- [Unitary Regression Model](https://c-huang-tty.github.io/posts/2021/01/27/unitary-regression-model/)
- [Multiple Regression Model](https://c-huang-tty.github.io/posts/2021/01/28/multiple-regression-model/)
- [Factor and Principle Component Analysis](https://c-huang-tty.github.io/posts/2021/01/29/factor-principle-component-analysis/)
- [Clustering Analysis](https://c-huang-tty.github.io/posts/2021/01/30/clustering-analysis/)
- [Summary](https://c-huang-tty.github.io/posts/2021/01/31/summary/)

